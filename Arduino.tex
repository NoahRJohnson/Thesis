\chapter{Arduino}

%BRIDGE FROM PREVIOUS SECTION
The Arduino Uno in this project acts as a bridge between hardware and software, allowing the the laptop to read sensor data from the rover, and control the speed of its wheels.

\section{Background}
Arduino development boards are printed circuit boards capable of running small embedded programs. They contain an on-board microcontroller, timing crystal, USB port, I/O pins and more. The specific board used in this project, an Arduino Uno, uses the ATmega328P microcontroller with a 16 MHz quartz timing crystal and 14 digital I/O pins. It also has 6 analog-to-digital converter I/O pins, but we won't make use of them in this project. 

Digital I/O pins can be configured to either read signals as input or generate them as output. Digital pins read input signals at specific times as binary values, i.e. the connected signal's voltage is read as either on or off compared to a certain threshold voltage. Following the standard Arduino literature, we will refer to these signals as either HIGH or LOW. When digital pins are configured to generate HIGH or LOW signals, they produce a relative output voltage above or below the threshold voltage.

\subsection{Servo Control Pulses} \label{sectionRCPulses}
An important use-case which pops up often when using the Arduino is that of interfacing with RC electronics. In this project's design, both the Sabertooth motor driver and the standard servo require their signal inputs to use the standard R/C transmission protocol.

This protocol involves sending brief HIGH pulses of variable width, between one and two milliseconds. There is a fixed delay between pulses, commonly about 20 ms of LOW signal. The width of the HIGH pulse communicates to a servo the desired position. Its internal components then drive its DC motors until the servo is rotated to the commanded position. In the case of the Sabertooth motor driver, the position is interpreted as a speed to drive the motors at.

\section{Arduino Uno Connections}
Refer back to Figure \ref{figRoverDesign} for a visual representation of how the Arduino Uno is connected to the other rover components.

\subsection{Hardware Interrupt Pins} \label{sectionHIP}
As one can see in Figure \ref{figRoverDesign}, only two optical quadrature encoders are used, placed on the front motors on the left and right side of the rover. This is due to a hardware limitation of the Arduino Uno. The ATmega328P microcontroller has only two interrupt pins, which are mapped to digital pins 2 and 3 on the Uno. These pins can trigger unique Interrupt Service Routines (ISRs) whenever the input signals change from LOW to HIGH voltage, or vice versa.

While it is possible to react to a change in any digital pin's voltage, it would be significantly slower than a hardware interrupt. An ISR is necessary to keep up with the fast rate of pin voltage changes that occur in the output of quadrature encoders.

If a different Arduino board such as the Mega were used, there would be sufficient hardware interrupt pins for all four encoders. Using a board with plentiful interrupts, one could even attach both channel outputs of the encoders to interrupt pins, rather than only one. This would double the encoders' resolution. See section \ref{sectionQuadEncoders} for more detail.

\subsection{Digital Pin Connections}
Each motor encoder has two output channels, A and B. Both encoders attach one of their output channels, channel A, to a hardware interrupt pin. In section \ref{sectionQuadEncoders} we will see why this configuration was chosen. The right motor's encoder connects channel A to pin 2, and channel B to pin 4. The left motor's encoder connects its channel A output to pin 3, and its channel B output to pin 7.

The S1 and S2 signal input terminals on the Sabertooth motor driver are connected to digital pins 5 and 6. The control signal for the hobby servo is connected to digital pin 9. The signal pin on the ultrasonic sensor is connected to digital pin 11. The Arduino's ground pin is connected to the ground of the motor driver's BEC, to ensure a common ground plane.

Most digital pin numbers used are arbitrary, and connections may be permuted without issue. The exceptions are pins 0-3, which must not be modified. Pins 0 and 1 must be left unattached for serial data transfer to work properly over USB. And pins 2 and 3 are hardware interrupt pins which must be used to handle the quadrature encoders' output.

\section{Motor Driver's Configuration}
The Sabertooth motor driver has two signal input terminals, S1 and S2, which allow the Arduino to issue instructions specifying how to drive the motors. The protocols used to communicate with the motor driver over these signal inputs are specified by six DIP switches on-board the driver. These DIP switches are manually flipped either up or down.

Setting switch 1 down and switch 2 up places the driver into R/C input mode, which configures S1 and S2 to expect servo control pulses, Ã  la R/C controllers. This protocol was briefly explained in section \ref{sectionRCPulses}. \cite{sabertoothUserGuide}

Turning switch 3 down selects the lithium cutoff mode, which detects the number of lithium cells in series powering the driver, and shuts off when the battery pack's voltage drops below 3.0V per cell, or 6.0V for the two cell battery pack this project uses. This prevents accidental damage to the 18650 cells which may be caused by over-discharge.

Flipping switch 4 down selects independent (differential) drive, which allows S1 and S2 to each independently control the speed of one motor channel. Using this mode, turning of the vehicle is achieved by lowering the relative speed of the motors on one side of the vehicle compared to the other.

Switch 5 is flipped up to ensure a linear rather than exponential response of the motors to the Arduino's input signal. Switch 6 is flipped down to select "microcontroller mode", which turns off auto-calibration of the zero-velocity input signal, and turns off an automatic timeout. Thus if the signal connection is somehow lost the motor driver will continue driving the motors according to the last signal received. This is necessary for smooth performance of the motors since the Arduino may slightly delay control pulses. Though this introduces a risk of loss of control should wires come disconnected, it is a small one that should only occur during a catastrophic crash.

\section{Arduino Sketch}
A sketch is Arduino-speak for an embedded program written for an Arduino board. There is an Arduino IDE which supports development of sketches in C or C++, and allows one to take advantage of a software library for common I/O interactions. After the code is written in this IDE, it is uploaded to the board over a USB serial connection. The board will then continuously execute the code found in the sketch's main loop as long as the board is powered. This embedded software interacts with the various sensors and other electronics on a low level, through reading from and writing to the Arduino's digital I/O pins.

One of the standard Arduino libraries is the Servo library. This library allows one to configure a digital pin to output RC control pulses, as explained in section \ref{sectionRCPulses}. The sketch used in this project uses this library to specify the speed of each set of wheels driven by the Sabertooth motor driver, and to control the position of the standard servo aiming the ultrasonic range sensor. The motor driver is sent pulses every 20 ms, with HIGH pulses from 1 ms to 2 ms. The standard servo is also sent pulses every 20 ms, with HIGH pulses from 0.75 ms to 2.25 ms as its datasheet specifies.

\subsection{Ultrasonic Sensor}
The PING))) ultrasonic distance sensor works by emitting a short burst of 40 kHz sound waves and timing the delay before an echo response. The Arduino triggers a ping by generating a brief 5 \(\mu\)s (microsecond) pulse on the sensor's bi-directional signal pin. The sensor then generates a HIGH output pulse, which continues until either the echo is received or the maximum amount of time, 18.5 ms, has passed. This time may then be multiplied by the speed of sound in air to calculate an estimated distance of the first object in front of the sensor. \cite{pingDocumentation}

The sketch uses the NewPing library to handle this protocol \cite{newPing}. This library provides a convenient method, ping() which returns the echo time in \(\mu\)s. The sketch avoids costly floating point computations by sending this echo time over serial rather than a distance.

\subsection{Servo}
The ultrasonic sensor can only detect objects which are roughly straight in front of it. Thus for the rover to have a better approximation of its surroundings, the sensor needs to be panned back and forth. This is what the standard servo it is attached to allows. The sketch makes use of the Servo library to control the servo with R/C pulses. An angular degree from 0 to 180 is written to a Servo object, and the Servo library handles generating the output signal corresponding to that position on the appropriate digital pin.

The sketch sweeps the servo back and forth one degree at a time, and at each step an ultrasonic ping is emitted. The echo time for that ping is measured, and the current values of all sensors are published. This means that the delay between servo steps defines the publishing frequency of sensor data on the Arduino. This delay is currently set to 100 ms, which corresponds to a 10 Hz publishing frequency. The frequency could be increased for future work, but a bare minimum delay of 30 ms is necessary to give the servo time to finish moving, and the PING))) sensor time to recover and prepare for the next ping.

The basic idea is shown in the following code for an arbitrary servo step size:
\begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
	\begin{lstlisting}[language=C++]
	while (servoPos < SERVO_LEFT) {
	sonicServo.write(servoPos); // Set servo position
	timer = millis(); // current time in ms
	while (millis() - timer <  SERVO_STEP_DELAY) {
	nh.spinOnce(); // handle callbacks
	}
	ping_time_uS = sonar.ping(); // Get echo time
	publishSensorMessages(servoPos, ping_time_uS);
	servoPos += SERVO_STEP_SZ;
	}
	\end{lstlisting}
\end{mdframed}

This code fragment is run inside the sketch's main loop, with a similar while-loop running right after, decrementing the servo position back to SERVO\_RIGHT.

millis() is an Arduino built-in function which uses a hardware timer to count how many milliseconds have passed since the board was turned on. The callback handling that occurs while waiting reads the incoming serial buffer for any data, and if motor commands are found, an appropriate callback function is executed. publishSensorMessages() sends over serial the ping echo time, the servo's current angle, and the tick counts of both encoders. Section \ref{sectionRosSerial} will further describe how this data is passed between laptop and Arduino.

\subsection{Quadrature Encoders} \label{sectionQuadEncoders}
An important function of the Arduino sketch is to track the movement of the motors. Our system may command the motor driver to move the rover's wheels with a certain fraction of the maximum available power, but it is difficult to predict with precision the resulting angular velocity. For one thing, the RPM of DC motors is proportional to the supplied voltage. But the voltage supplied to the motors through the motor driver is coming from an external li-po battery pack, which generates variable voltage. It starts at 8.4V and drops to a minimum of 6.0V before the motor driver shuts off. Thus even if the same servo control pulse is continuously sent to the motor driver, the motors' angular velocity will decrease over time.

In order to determine the true angular velocity of the motors, rotary encoders are attached to them. These feedback devices are incremental position encoders, meaning they monitor the change in the motor shaft's position compared to some starting position. 

\begin{wrapfigure}{l}{0.5\textwidth}
	\caption{\cite{fig_optical_encoders}}
	\centering
	\includegraphics[width=0.5\textwidth]{opticalEncoders}
	\label{FigOpticalEncoders}
\end{wrapfigure}

The motor encoders which came with the Lynxmotion rover kit are optical quadrature encoders. This type of encoder attaches a flat disk with thin slits known as the code disk to the motor's gear shaft. Two photodiodes, components which transform light into electric current, are placed above the disk side by side. A light source shines light through the disk from the other side. See Figure \ref{FigOpticalEncoders} for a visual illustration.

As the motor spins the gear shaft, the code disk turns with it. This produces an on-off pattern of light on the photodiodes, which produce two square waves as signal outputs. These two channels of output pulses are referred to as channels A and B. Depending on the direction of rotation, channel A's square wave will either lag behind or be ahead of channel B. This can be seen in Figure \ref{FigQuadChannels} which shows example output pulses as a motor turns clockwise (CW) or counter-clockwise (CCW). \cite{encoderBlog}

The number of slits in the code disk corresponds directly to how many pulses each channel will produce in one revolution of the DC motor. This is known as the pulses per revolution (PPR), and is given by the manufacturer. By counting how many pulses occur in one second, and using the PPR, one can calculate the angular speed of the motor. If one wishes for greater resolution, they can watch each square wave for a change in voltage from LOW to HIGH or HIGH to LOW. This gives a maximum resolution of \(4 * PPR\) detectable position increments per revolution.

\begin{figure}[h]
	\caption{\cite{fig_quad_channels}}
	\centering
	\includegraphics[width=\textwidth]{quadrature}
	\label{FigQuadChannels}
\end{figure}

Handling rapid changes in voltage is exactly what hardware interrupts are designed for. Unfortunately, for maximum resolution each encoder needs two hardware interrupt pins, one for each channel. The Arduino Uno only has two hardware interrupt pins, and our rover has two sides. It would be nice if we could at least use two encoders, one for each side.

We achieve this by reacting to changes in voltage in only one channel per encoder. In the two tables in Figure \ref{FigQuadChannels}, LOW voltage values are encoded as 0, and HIGH voltage values as 1. The first plot in the figure shows the output of the two channels when the motor is moving in the CW direction.  When channel A transitions from the section labeled 1 to section 2, it is rising from 0 to 1, and channel B has value 0. That information alone tells us that the motor's gear shaft is turning, but not in what direction. However, at the next transition between sections 2 and 3, channel A falls from 1 to 0, and channel B has value 1. Now we are confident that channel B began its pulse after channel A. This means that the photodiode generating channel B detected light after channel A's photodiode, i.e. the code disk is turning in the direction of photodiode A to B. Datasheet specifications will tell us that this translates to the CW direction. It turns out that for each channel A transition event, the previous and new channel values are sufficient to uniquely determine the direction of rotation of the motor. Thus, while only monitoring one of the channels lowers our resolution to \(2 * PPR\) counts per revolution, it allows us to use hardware interrupts for two quadrature encoders rather than only one. \cite{encoderBlog}

The sketch uses an implementation described in \cite{encoderBlog}, which creates a lookup table using the four binary digits representing the previous and current channel states. These digits form a four-bit binary number, which indexes into a sixteen element array. Each element of this array stores either 1, -1, or 0, where 1 represents a movement in the CW direction, -1 represents a movement in the CCW direction, and 0 represents an indeterminate transition. This lookup table is then used by the sketch when it reacts to a hardware interrupt caused by the channel A output of one of the encoders. When this interrupt occurs, the code reads the values of channels A and B from the corresponding digital pins, and combines them with the previous values to find the appropriate index in the lookup table. The value at that index is then added to a global counter variable, which keeps track of the net number of incremental movements from the motor's starting position. A net negative number indicates how far the motor has rotated in the CCW direction since it started, and a net positive number indicates how far the motor has rotated in the CW direction. \cite{encoderBlog}

The implementation described above is shown in the following C code of the ISR for the left encoder. \cite{encoderBlog}
\begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
	\begin{lstlisting}[language=C++]
	volatile long encLeftCount = 0L;
	const int8_t encoder_lookup_table[] =
	{0,0,0,-1,0,0,1,0,0,1,0,0,-1,0,0,0};
	void encoderLeft_isr() {
	static uint8_t encLeft_val = 0;
	encLeft_val = encLeft_val << 2;
	encLeft_val = encLeft_val |
	  ( ((PIND & 0b100) >> 1) | 
	  ((PIND & 0b10000) >> 4) );
	encLeftCount = encLeftCount +
	  encoder_lookup_table[encLeft_val & 0b1111];
	}
	\end{lstlisting}
\end{mdframed}

When the digital pin connected to the left encoder's Channel A output changes, the main loop of the sketch is interrupted, and this ISR is executed. Until this ISR finishes, no other code is run, including other ISRs, though they may be flagged for future execution. Therefore ISRs must be as fast as possible, to not cause any interrupt events to be dropped, and to ensure that the main loop continues running smoothly.

To this end, this ISR makes use of constants and low-level C and avr microcontroller commands to ensure a speedy execution, at the price of readability. PIND is an avr command which returns input readings from digital pins 0-7 encoded into a byte. Bit shifting and masking are then used to extract and store the values of pins 2 (channel A) and 4 (channel B) into the two least significant bits of the encLeft\_val variable. This variable is static, and so retains its value between ISR executions. The count is then incremented according to the lookup table.

When the sketch's main loop publishes sensor readings, it needs to publish the current encoder tick count for the right and left encoders. However, reading from multi-byte variables which are accessed within and without an ISR risks data corruption in the event that the ISR interrupts the main thread in-between readings of bytes. Since the encoder tick count variables are four bytes long, interrupt guards must be used around a read to make it atomic. These guards temporarily stop the custom ISR from executing while the global variables are copied over to local ones. This is shown for the left encoder count in the following snippet from the sketch:
\begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
	\begin{lstlisting}[language=C++]
	detachInterrupt(digitalPinToInterrupt(encLeftAPin));
	encMsg.leftTicks = encLeftCount;
	attachInterrupt(digitalPinToInterrupt(encLeftAPin),
	  encoderLeft_isr, CHANGE);
	t = 0;
	\end{lstlisting}
\end{mdframed}

Similar guards are used for the right encoder count variable. 

Because we are turning interrupts off briefly, there is the risk that we could miss an interrupt event on one of the channel A pins. Missing an edge pulse from one of the encoders would not only lose that tick, but would also throw off the next value we index into the lookup table. Luckily, the Arduino has a single-bit interrupt event flag for every interrupt event. Therefore in the worst case scenario, an encoder interrupt event occurs just after the ISR handler is detached, and that event is flagged. As long as the ISR is reattached and handles that flag before a second interrupt event occurs, there won't be a problem. After reattaching the ISR, the next program instruction is guaranteed to be executed before handling any flagged events. To ensure speedy handling of a flagged event, a meaningless assignment of zero is made to the local variable t.

Let's calculate how often each interrupt event occurs. Each encoder generates 100 pulses per revolution. We will only be watching one of the square waves (output channel A), so that's 200 edge transitions per revolution. The motors are rated for 200 rpm, so at maximum speed the two encoders would revolve less than 3.4 times per second. So there will be at most \[3.4\ rev/sec * 200\ events/rev = 680\ events/sec\]
Meaning we are guaranteed to have at least \(1 / 680 \approx 1.4\ ms\) between encoder interrupt events.

So the interrupt guards need to take significantly less than \(1.4\ ms\) in order to allow a flagged interrupt event to be handled before the next event occurs. Each global encoder count variable is four bytes, so assignment compiles to four machine instructions. The assignment of zero to the one-byte variable t takes one machine instruction. The helper macro digitalPinToInterrupt() is a preprocessor \#define, and so takes zero machine instructions. Therefore there are five total machine instructions executed before the ISR is executed. The Arduino Uno uses a 16 MHz quartz timing crystal, so executing one instruction takes \[1 / (16000000\ Hz) = 0.000000625\ seconds = 62.5\ nanoseconds\]

Thus to run the five instructions takes \(5 * 62.5\ ns = 0.3125\ \mu s\). Then the flagged event must be handled. External interrupt calling has an overhead of 5.125 \(\mu s\), to enter and leave the function \cite{gammonInterrupts}. Thus as long as the ISR executes in less than \(1.4\ ms - 0.0003125\ ms - 0.005125\ ms = 1.3945625\ ms\), the sketch will never miss an encoder event. Testing of the ISR indicates that this is an order of magnitude more time than needed.