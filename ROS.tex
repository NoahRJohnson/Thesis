\chapter{ROS}

\section{Overview}
The Robot Operating System (ROS) is a meta operating system for open-source robotics.

package management

asynchronous messaging between components

\subsection{Messages}
publishing and subscribing messages

\subsection{Topics}
All software components in this project communicate using the asynchronous, distributed framework supported by ROS.

many to many

ROS Master, like a DNS server
node to node, TCP/IP sockets

\subsection{Packages}
contain nodes, message definitions, and service files
There are also meta-packages which are, simply enough, collections of related packages.

\subsection{Nodes}
processes

\subsection{Launch Files}
XML launch files
systems get complicated, with dozens of nodes
nobody wants to go through and manually start all those up, so it makes sense to streamline and aggregate startup (launch) files for all of them in the same place
allows bringing multiple nodes up at once, and also specifying their parameters in YAML files

\subsection{Frames}
coordinate axes
reference frames
position and orientation
quaternion vectors represent orientation
messages have frame\_ids detailing which frame they are in

\subsection{Transforms}
conversions between frames
handled by the ROS package tf
broadcasting transforms


\subsection{User defined packages}
auto\_rover package


\section{rosserial} \label{sectionRosSerial}
Communication between the Arduino and laptop is handled with the ROS metapackage rosserial. Different client packages support different client machines, such as embedded linux devices, or different microcontroller boards. These client packages create local support libraries or header files on those machines, which use a serialization protocol to send and receive ROS messages over a serial port. On the other side of the serial connection, host packages run a bridging node which communicates with the ROS network on behalf of the client machine. Subscribed topics have their messages serialized and sent to the client machine, and outgoing messages from the client are de-serialized and published. 

\subsection{rosserial\_arduino}
rosserial\_arduino is one client package of rosserial, which creates an Arduino library to provide bare-bones ROS support to sketches. The sketch running on this project's Uno board uses this library to publish sensor data as messages, and subscribe to motor command topics.

Every time the sketch wishes to update the laptop with its newest sensor readings, it publishes three messages. First the servo angle in degrees is published to the "/ping/angleDeg" topic, as a standard Int8 message. This message just contains a single data field: an 8-bit signed integer. Next the echo time in microseconds is published to the "/ping/timeUS" topic, as a standard UInt16 message which contains a single 16 bit data field representing an unsigned integer. Lastly the two encoder tick counts are both placed into a single custom message called EncCount, and published to the "/odom/encTicks" topic. This custom message type has two 32 bit fields, one for each encoder. This message type will be further explained in section \ref{sectionEncCount}.

When the sketch is waiting between updates, it continually listens to the serial port for motor commands. These commands are Int8 messages on the "/cmd/left" or "/cmd/right" topics, which the sketch subscribes to. When these messages are found in the serial input buffer, a short callback function is executed, which writes the R/C pulse command to the proper motor channel.

Arduino boards use different types of memory. Flash memory is used to store sketch code, and static random access memory (SRAM) is used to store dynamic variables at runtime. The Uno has 32kB of flash memory, but only 2kB of SRAM. The rosserial Arduino library is large, and takes up quite a lot of SRAM space. Its input and output serial buffers alone use 560 bytes. This makes running out of space for local variables quite easy, which can lead to instability and crashes when running the sketch. To save space, a modified version of rosserial\_arduino which supports storing constant strings in flash memory rather than SRAM has been used. Since topic names and error messages use long descriptive strings, this saves several hundred kB of space in SRAM and ensures the sketch's stability.
%https://github.com/strothmw/rosserial

The rosserial Arduino library abstracts away most of the serial communication protocol, but does allow the baud rate to be specified. In this use case, baud rate is equivalent to bits per second. The more bits per second sent over serial, the more frequently the microcontroller needs to sample the incoming and outgoing line. So the baud rate cannot be set arbitrarily high, as the Uno has a limited clock speed. If it is set too low, however, then the stream of sensor data being published would overwhelm the connection. Significantly less data will be streaming in than transmitted out, so the amount of outgoing data is the deciding factor. Thus to calculate an appropriate baud rate, the amount of sensor data transmitted per second must be known.

rosserial uses a serial protocol with 8 bytes of overhead for every message. Each sensor update publishes three messages: an eight-byte EncCount message, a one-byte Int8 message, and a two-byte UInt16 message. This means that each update pushes 11 bytes of data in three messages, with 24 bytes of overhead. Thus a total of 35 bytes are sent over serial.

Since the PING))) sensor requires a minimum delay of 30 ms between pings, the sketch cannot publish its sensor values at a rate higher than 33 Hz. Therefore the sketch will not push more than:
\[33\ Hz * 35\ Bytes = 1155\ Bytes\ per\ second\ (Bps)\]

The Uno uses one start bit and one stop bit to surround each byte of information sent over serial. Thus it takes 10 bits to send one byte of information. Therefore the minimum baud rate required is:
\[1155\ Bps * 10\ bits\ per\ byte = 11550\ bits\ per\ second\]

We'll choose a standard baud rate of 28,800 to more than double that for some breathing room, and to account for the fact that the rosserial Arduino library occasionally transmits time-keeping and synchronization messages of its own.

\subsection{rosserial\_python}
rosserial\_python is one host package of rosserial, which acts as a bridge between the Arduino and the ROS network. It runs a node on the laptop which communicates with the Arduino using the rosserial protocol. It automatically handles setup, communication with the ROS master, subscription, and publishing on behalf of the Arduino. When launched, the serial node must be configured to use the same baud rate as the Arduino: 28,800. It must also be configured to connect to whichever serial port name the Arduino uses. For simplicity, a symbolic link was created using a udev rule on the laptop, to ensure that the port name will always be accessible as "/dev/arduino". %https://www.clearpathrobotics.com/2015/01/arduino-ros/

\section{differential\_drive}
The differential\_drive package was created by Jon Stephan to create a simple interface for controlling a differential-drive robot \cite{}. Differential drive is . Because the rover has four wheels, turning in-place involves wheel slippage. This is referred to as a skid-steering design. 

(high variance in odometry tick count readings)

forked from %https://github.com/jfstepha/differential-drive

modified to use EncCount messages

\subsection{diff\_tf}
The diff\_tf node 
modified to not publish a transform
We use a simple
rolling average with the kinematics equations for a differential drive
robot (an approximation of our skid-steering rover), where the two imaginary
wheels on both side of the rover are assumed to 'exist' at an average position
of the two actual wheels. This average then gives us an estimate of the
position and velocity of our rover, which we publish in an Odometry message.
This odometry message is essentially dead reckoning, and is one of the inputs
fused into the state estimation node. 

produce odometry messages from encoder ticks

encoder ticks per meter must be calibrated

covariance matrix

\subsection{virtual\_joystick}
generate twist messages, like the ROS navigation stack would

\subsection{twist\_to\_motors}
translate twist messages to motor velocities for each motor channel, publish those


\subsection{pid\_velocity}
translate motor velocities to actual motor commands, which rosserial\_python will transmit over serial to the arduino

\subsection{Encoder Calibration}

\subsection{PID Parameter Tuning}

\section{Ros Sensors App}
Android app to publish IMU and GPS data from a smartphone.

phone frame

\subsection{GPS}
GPS receivers background

navsatfix message
covariance matrix

\subsection{IMU}
IMU chips background: magnetometers, accelerometers, gyroscopes
what a quaternion is

publishes IMU message

IMU messages are expected to be in ENU reference frame, instead of NED.

Android TYPE\_ROTATION\_VECTOR sensor fuses magnetometer and accelerometer data to produce an quaternion representation of an orientation in the ENU frame.

% https://source.android.com/devices/sensors/sensor-types#rotation_vector
Android accelometer readings tell us the linear acceleration of the rover, but are reported with respect to the local orientation of the phone, and so the node converts them to the ENU orientation before publishing them, in the phone frame (which just specifies a static translation)

Android gyroscope readings tell us the angular velocity of the rover, but are reported with respect to the local axes of the phone. However, our rover operates solely in 2D, and so we aren't interested in angular velocities of roll or pitch. And since the phone lays face-up on top of the rover, the phone's local z axis is the same as the ENU up axis, and so we don't need to transform the gyroscope reading for rad/sec rotation of yaw.



covariance matrices

\subsection{How to use}
usb tethering
on linux


\section{robot\_localization package}
%http://docs.ros.org/kinetic/api/robot_localization/html/

package for state estimation

\cite{robot_localization_paper}

\subsection{Data Format Conventions}
REP-103 and REP-105 for conventions
true north, magnetic declination




\section{auto\_rover}
custom package
this is where custom message type, EncCount is defined, and header files are created
\subsection{EncCount} \label{sectionEncCount}

\subsection{range\_converter}
ping sensor at ultrasound frame

Adjust code for conversion of ultrasonic sensor ping times to distance, to take into account the ambient air temperature
If an echo has been received, then the speed of sound in air in m/s, \(C_{air}\), is calculated using the current air temperature in Celsius \(T_C\):
\[C_{air} = 331.5 + (0.6 * T_C)*\]

Multiplying \(C_{air}\) by the duration of the timed output pulse gives the estimated distance of the first object in front of the sensor.

Subscribes to /ping/timeUS and /ping/angleDeg topics, reads servo angle and ping time from those topics. Those messages sent from arduino to minimize amount of data being sent over serial. Then this node converts that to a distance in meters and an ultrasound -> base\_link transform. transform uses static translation from center of rover to center of PING))) sensor, as well as instantaneously changing rotation at each ping snapshot.

\subsection{}
First ekf\_localization node takes in odometry estimate from wheel encoders via diff\_tf node, and IMU message from phone node. Produces a fused estimate of odometry.

navsat\_transform\_node takes in odometry message from first ekf node, which is the robotâ€™s current position estimate in the frame specified by its start location. It also takes in the navsatfix and imu messages from the phone, and fuses all these to produce a different odometry estimate which is the gps data converted to the coordinates of the robot's world frame.

Second ekf\_localization node fuses the gps and odometry outputs from the previous two nodes into a final odometry message which is the final estimation of the robot's current state.


\cite{robot_localization_paper}